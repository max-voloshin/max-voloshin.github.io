---
layout: post

title: PHP & Shell
subtitle: "How it works together"
cover_image: blog-cover.jpg

excerpt: "PHP developers deal with web development in most cases, where start point is request to web server.
  In spite of this we work with Shell. In order to do some tasks more effectively, worth looking
  the details of intersection of PHP and Shell.
"

---

## Why PHP developers should know about Shell?

PHP developers deal with web development in most cases, where start point is request to web server.
In spite of this we work with Shell:

* we use a terminal emulator:  iTerm / Gnome Terminal / Konsole / xterm / etc
* we log to remote machine via ssh
* we use such PHP function as ``exec`` / ``shell_exec`` / ``system`` / ``passthru`` / ``proc_open`` or backtick operator `` `...` ``
* we create command line interface to own application for ability to automate routine actions  

In order to do these tasks more effectively, worth looking the details of intersection of PHP and Shell.

## What is Shell?

Shell – interpreter of command line language which is determined by POSIX standard.
There are couple of implementations:

* Original Bourne Shell – **sh** – used in most UNIX systems
* Bourne Again Shell – **bash** – used in most Linux systems
* Debian Almquist Shell – **dash** – used in Debian
* Z Shell – **zsh** – used by advanced users of command line :)
* etc

## Running PHP application from Shell

{% highlight php %}
<?php //sapi.php
echo PHP_SAPI . PHP_EOL . php_sapi_name() . PHP_EOL;
{% endhighlight %}

{% highlight sh %}
$ php sapi.php
cli
cli
{% endhighlight %}

Thus we can determine running via Shell with constant ``PHP_SAPI`` or function ``php_sapi_name``.

## Shell variables and environment variables

We can use variables in Shell:

{% highlight sh %}
$ FOO=value
$ echo $FOO
value
$ BAR='another value'
$ echo "$FOO and $BAR"
value and another value
{% endhighlight %}

As part of the Shell among the variables there is a special set - the environment variables.
Current environment variables are able to be shown with tool ``env``:

{% highlight sh %}
$ env
PATH=/usr/local/bin:/usr/bin:/bin
HOME=/Users/maxvoloshin
USER=maxvoloshin
SHELL=/bin/zsh
PWD=/Users/maxvoloshin
_=/usr/bin/env
{% endhighlight %}

If we want transform Shell variable to environment variable we should use command ``export``:

{% highlight sh %}
$ FOO=value
$ export FOO
$ env
...
FOO=value
{% endhighlight %}

With each Shell execution of commands the new Shell process is created, which copy environment variables of parent process.
Exclusively for new process it is possible to pass special value of environment variable or even to pass new variable.

{% highlight sh %}
$ FOO=value
$ FOO=new BAZ=value env
...
FOO=new
BAZ=value
$ echo $FOO
value
$ echo $BAZ
$ 
{% endhighlight %}

Take into account that in current context the value of variable ``FOO`` is not changed and variable ``BAZ``
is not created (command ``echo $BAZ`` shows nothing).

## Passing parameters from Shell to PHP application

### Usage of environment variables

Values of environment variables are available in PHP application via function ``getenv``:

{% highlight php %}
<?php //getenv.php
echo getenv('FOO') . PHP_EOL;
{% endhighlight %}

Look at Shell:

{% highlight sh %}
$ FOO=value php getenv.php
value
{% endhighlight %}

Depending on PHP configuration ``request_order`` and ``variables_order`` environment variable are available
in superglobal variables ``$_SERVER``, ``$_REQUEST`` and ``$_ENV``. 

### Usage of command arguments

Receiving information about command arguments is possible via ``$_SERVER['argc']`` and ``$_SERVER['argv']``:
 
{% highlight php %}
<?php //argc_argv.php
print_r($_SERVER['argc']);
echo PHP_EOL;
print_r($_SERVER['argv']);
{% endhighlight %}

Usage:

{% highlight sh %}
$ php argc_argv.php some -arguments --here
4
Array
(
    [0] => argc_argv.php
    [1] => some
    [2] => -arguments
    [3] => --here
)
{% endhighlight %}

Depending on PHP configuration ``register_argc_argv`` this information are available in superglobal variables ``$argc`` and ``$argv``.

Alternative approach is usage of function ``getopt``:

{% highlight php %}
<?php //getopt.php
var_dump(getopt('ab:c::', array('foo', 'bar:', 'baz::')));
{% endhighlight %}

Usage:

{% highlight sh %}
$ php getopt.php -a -b=value -c -c=value --foo --bar=value1 --bar=value2 --baz
array(6) {
  ["a"]=>
  bool(false)
  ["b"]=>
  string(5) "value"
  ["c"]=>
  array(2) {
    [0]=>
    bool(false)
    [1]=>
    string(5) "value"
  }
  ["foo"]=>
  bool(false)
  ["bar"]=>
  array(2) {
    [0]=>
    string(6) "value1"
    [1]=>
    string(6) "value2"
  }
  ["baz"]=>
  bool(false)
}
{% endhighlight %}

## Running PHP application in POSIX style

Running PHP applications as ``php app.php``, of course, is a working approach,
but it can be done in a native style for the POSIX systems, similar to how we use utilities ``cat``, ``ls``, ``cp``, etc.

Let's create file ``argv``:

{% highlight sh %}
$ touch argv
{% endhighlight %}

For the execution of such a program by the user, the file must have the appropriate owners and permissions.
Tool ``ls`` helps to receive that information:

{% highlight sh %}
$ ls -l argv
-rw-r--r--  maxvoloshin  staff  ...
{% endhighlight %}

Look at parts of output (from left to right):

* ``-`` – regular file
* ``rw-`` – owner has permissions to read and write file
* ``r--`` – users of group have permissions to read file
* ``r--`` – all users have permissions to read file
* ``maxvoloshin`` – owner of file
* ``staff`` – group of file

For execution this file by user ``maxvoloshin`` must do one of the following conditions:

* user ``maxvoloshin`` is owner of file and execution by owner is allowed
* user ``maxvoloshin`` is included in the group ``staff`` and execution by group is allowed
* execution by any user is allowed

Permissions can be set by tool ``chmod``, for example, to allow execution of file by owner:

{% highlight sh %}
$ chmod u+x argv
$ ls -l argv
-rwxr--r-- ...
{% endhighlight %}

Fourth character (``x``) describes the permissions to execute the file by owner.

The file must contain "shebang line" with PHP call, then file will be executed via PHP.
"Shebang line" – first line of file that starts with ``#!`` and contains call of program for execution of file.

On different systems PHP interpreter can be located on different paths,
so it is commonly used tool ``env`` for calling program by name.
Tool ``env`` resolves path to program by environment variables.

{% highlight php %}
#!/usr/bin/env php
<?php //argv
print_r($_SERVER['argv']);
{% endhighlight %}

The easiest way to execute file in Shell – call it by absolute or relative path:

{% highlight sh %}
$ /Users/maxvoloshin/argv
Array
(
    [0] => /Users/maxvoloshin/argv
)

$ ./argv
Array
(
    [0] => ./argv
)
{% endhighlight %}

In most cases such way is not convenient for working with global tools ,
because it is necessary to keep in mind path of each tool.
This task is solved by environment variable ``PATH``.

{% highlight sh %}
$ echo $PATH
/usr/local/bin:/usr/bin:/bin
{% endhighlight %}

Value of this variable contains paths to directories with tools (``:`` is used as separator).
Let's add current directory to environment variable ``PATH``:

{% highlight sh %}
$ PATH=$PATH:`pwd`
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/Users/maxvoloshin
{% endhighlight %}

Tool ``which`` shows absolute path to tool by name:

{% highlight sh %}
$ which argv
/Users/maxvoloshin/argv
{% endhighlight %}

Thus we can execute application by name:

{% highlight sh %}
$ argv
Array
(
    [0] => /Users/maxvoloshin/argv
)
{% endhighlight %}