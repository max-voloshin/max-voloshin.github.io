---
layout: post

title: PHP & Shell
subtitle: "How it works together"

excerpt: "PHP developers deal with web development in most cases, where start point is request to web server.
  In spite of this we work with Shell. In order to do some tasks more effectively, worth looking
  the details of intersection of PHP and Shell.
"

---

## Why PHP developers should know about Shell?

PHP developers deal with web development in most cases, where start point is request to web server.
In spite of this we work with Shell:

* we use a terminal emulator:  iTerm / Gnome Terminal / Konsole / xterm / etc
* we log to remote machine via ssh
* we use such PHP function as ``exec`` / ``shell_exec`` / ``system`` / ``passthru`` / ``proc_open`` or backtick operator `` `...` ``
* we create command line interface to own application for ability to automate routine actions  

In order to do these tasks more effectively, worth looking the details of intersection of PHP and Shell.

## What is Shell?

Shell – interpreter of command line language which is determined by POSIX standard.
There are couple of implementations:

* Original Bourne Shell – **sh** – used in most UNIX systems
* Bourne Again Shell – **bash** – used in most Linux systems
* Debian Almquist Shell – **dash** – used in Debian
* Z Shell – **zsh** – used by advanced users of command line :)
* etc

## Running PHP application from Shell

{% highlight php %}
<?php //sapi.php
echo PHP_SAPI . PHP_EOL . php_sapi_name() . PHP_EOL;
{% endhighlight %}

{% highlight sh %}
$ php sapi.php
cli
cli
{% endhighlight %}

Thus we can determine running via Shell with constant ``PHP_SAPI`` or function ``php_sapi_name``.

## Shell variables and environment variables

We can use variables in Shell:

{% highlight sh %}
$ FOO=value
$ echo $FOO
value
$ BAR='another value'
$ echo "$FOO and $BAR"
value and another value
{% endhighlight %}

As part of the Shell among the variables there is a special set - the environment variables.
Current environment variables are able to be shown with tool ``env``:

{% highlight sh %}
$ env
PATH=/usr/local/bin:/usr/bin:/bin
HOME=/Users/maxvoloshin
USER=maxvoloshin
SHELL=/bin/zsh
PWD=/Users/maxvoloshin
_=/usr/bin/env
{% endhighlight %}

If we want transform Shell variable to environment variable we should use command ``export``:

{% highlight sh %}
$ FOO=value
$ export FOO
$ env
...
FOO=value
{% endhighlight %}

With each Shell execution of commands the new Shell process is created, which copy environment variables of parent process.
Exclusively for new process it is possible to pass special value of environment variable or even to pass new variable.

{% highlight sh %}
$ FOO=value
$ FOO=new BAZ=value env
...
FOO=new
BAZ=value
$ echo $FOO
value
$ echo $BAZ
$ 
{% endhighlight %}

Take into account that in current context the value of variable ``FOO`` is not changed and variable ``BAZ``
is not created (command ``echo $BAZ`` shows nothing).

## Passing parameters from Shell to PHP application

### Usage of environment variables

Values of environment variables are available in PHP application via function ``getenv``:

{% highlight php %}
<?php //getenv.php
echo getenv('FOO') . PHP_EOL;
{% endhighlight %}

Look in Shell:

{% highlight sh %}
$ FOO=value php getenv.php
value
{% endhighlight %}

Depending on PHP configuration ``request_order`` and ``variables_order``, environment variable are available
in superglobal variables ``$_SERVER``, ``$_REQUEST`` and ``$_ENV``. 

### Usage of command arguments

Receiving information about command arguments is possible via ``$_SERVER['argc']`` and ``$_SERVER['argv']``:
 
{% highlight php %}
<?php //argc_argv.php
print_r($_SERVER['argc']);
echo PHP_EOL;
print_r($_SERVER['argv']);
{% endhighlight %}

Usage:

{% highlight sh %}
$ php argc_argv.php some -arguments --here
4
Array
(
    [0] => argc_argv.php
    [1] => some
    [2] => -arguments
    [3] => --here
)
{% endhighlight %}

Depending on PHP configuration ``register_argc_argv``, this information are available in superglobal variables ``$argc`` and ``$argv``.

Alternative approach is usage of function ``getopt``:

{% highlight php %}
<?php //getopt.php
var_dump(getopt('ab:c::', array('foo', 'bar:', 'baz::')));
{% endhighlight %}

Usage:

{% highlight sh %}
$ php getopt.php -a -b=value -c -c=value --foo --bar=value1 --bar=value2 --baz
array(6) {
  ["a"]=>
  bool(false)
  ["b"]=>
  string(5) "value"
  ["c"]=>
  array(2) {
    [0]=>
    bool(false)
    [1]=>
    string(5) "value"
  }
  ["foo"]=>
  bool(false)
  ["bar"]=>
  array(2) {
    [0]=>
    string(6) "value1"
    [1]=>
    string(6) "value2"
  }
  ["baz"]=>
  bool(false)
}
{% endhighlight %}

## Running PHP application in POSIX style

Running PHP applications as ``php app.php``, of course, is a working approach,
but it can be done in a native style for the POSIX systems, similar to how we use utilities ``cat``, ``ls``, ``cp``, etc.

Let's create file ``argv``:

{% highlight sh %}
$ touch argv
{% endhighlight %}

For the execution of such a program by the user, the file must have the appropriate owners and permissions.
Tool ``ls`` helps to receive that information:

{% highlight sh %}
$ ls -l argv
-rw-r--r--  maxvoloshin  staff  ...
{% endhighlight %}

Look at parts of output (from left to right):

* ``-`` – regular file
* ``rw-`` – owner has permissions to read and write file
* ``r--`` – users of group have permissions to read file
* ``r--`` – all users have permissions to read file
* ``maxvoloshin`` – owner of file
* ``staff`` – group of file

For execution this file by user ``maxvoloshin`` must do one of the following conditions:

* user ``maxvoloshin`` is owner of file and execution by owner is allowed
* user ``maxvoloshin`` is included in the group ``staff`` and execution by group is allowed
* execution by any user is allowed

Permissions can be set by tool ``chmod``, for example, to allow execution of file by owner:

{% highlight sh %}
$ chmod u+x argv
$ ls -l argv
-rwxr--r-- ...
{% endhighlight %}

Fourth character (``x``) describes the permissions to execute the file by owner.

The file must contain "shebang line" with PHP call, then file will be executed via PHP.
"Shebang line" – first line of file that starts with ``#!`` and contains call of program for execution of file.

On different systems PHP interpreter can be located on different paths,
so it is commonly used tool ``env`` for calling program by name.
Tool ``env`` resolves path to program by environment variables.

{% highlight php %}
#!/usr/bin/env php
<?php //argv
print_r($_SERVER['argv']);
{% endhighlight %}

The easiest way to execute file in Shell – call it by absolute or relative path:

{% highlight sh %}
$ /Users/maxvoloshin/argv
Array
(
    [0] => /Users/maxvoloshin/argv
)

$ ./argv
Array
(
    [0] => ./argv
)
{% endhighlight %}

In most cases such way is not convenient for working with global tools ,
because it is necessary to keep in mind path of each tool.
This task is solved by environment variable ``PATH``.

{% highlight sh %}
$ echo $PATH
/usr/local/bin:/usr/bin:/bin
{% endhighlight %}

Value of this variable contains paths to directories with tools (``:`` is used as separator).
Let's add current directory to environment variable ``PATH``:

{% highlight sh %}
$ PATH=$PATH:`pwd`
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/Users/maxvoloshin
{% endhighlight %}

Tool ``which`` shows absolute path to tool by name:

{% highlight sh %}
$ which argv
/Users/maxvoloshin/argv
{% endhighlight %}

Thus we can execute application by name:

{% highlight sh %}
$ argv
Array
(
    [0] => /Users/maxvoloshin/argv
)
{% endhighlight %}

## Streams: input, output and errors

Each program in Shell can receive data from ``STDIN`` (input stream) and send data to ``STDOUT`` (output stream)
and ``STDERR`` (errors stream):

<div class="full"><img src="/images/shell-streams.png"></div>

For working with those streams in PHP (CLI mode) we should use special constants:
 
{% highlight php %}
STDIN  = fopen('php://stdin', 'r')
STDOUT = fopen('php://stdout', 'w')
STDERR = fopen('php://stderr', 'w')
{% endhighlight %}

### Usage of output stream

{% highlight php %}
#!/usr/bin/env php
<?php //stdout
fwrite(STDOUT, "Content\n"); //echo "Content\n"
{% endhighlight %}

Usage:

{% highlight sh %}
$ stdout
Content
{% endhighlight %}

Additionally we can redirect output to file:

{% highlight sh %}
$ stdout > file
$ cat file
Content
{% endhighlight %}

Also we can append output to existing file:

{% highlight sh %}
$ stdout > file
$ stdout >> file
$ cat file
Content
Content
{% endhighlight %}

**ProTip**: *Do not implement those features in your application because its are implemented in Shell already.*

### Usage of errors stream

Taking into account that the output can be redirected, good practice is to split the output and errors.
For example, we want notify user in case uncaught exception:

{% highlight php %}
#!/usr/bin/env php
<?php //stdout_stderr
fwrite(STDOUT, "Content\n");
set_exception_handler(function(Exception $e) {
   fwrite(STDERR, $e->getMessage());
});
throw new Exception('Error!');
{% endhighlight %}

Usage:

{% highlight sh %}
$ stdout_stderr
Content
Error!
{% endhighlight %}

Looks like simple output, but we can feel the difference if we use redirection:

{% highlight sh %}
$ stdout_stderr > file
Error!
$ cat file
Content
{% endhighlight %}

We can redirect errors to file:

{% highlight sh %}
$ stdout_stderr 2> file
Content
$ cat file
Error!
{% endhighlight %}

We can redirect union of output and errors to file:

{% highlight sh %}
$ stdout_stderr > file 2>&1
$ cat file
Content
Error!
{% endhighlight %}

We can redirect output and errors separately:

{% highlight sh %}
$ stdout_stderr > content 2> error
$ cat content
Content
$ cat error
Error!
{% endhighlight %}

### Usage of input stream

One of the approaches to pass data to application is usage of input stream:

{% highlight php %}
#!/usr/bin/env php
<?php //stdin
var_dump(trim(stream_get_contents(STDIN)));
{% endhighlight %}

Usage:

{% highlight sh %}
$ stdin
Hello from Shell
<Ctrl+D>
string(16) "Hello from Shell"
{% endhighlight %}

After starting ``stdin``, Shell waits input of contents.
When input is finished, combination ``Ctrl + D`` must be pressed.

There is ability to redirect content of file to input stream:

{% highlight sh %}
$ stdout > file
$ cat file
Content
$ stdin < file
string(7) "Content"
{% endhighlight %}

or arbitrary text:

{% highlight sh %}
$ stdin <<< "some string"
string(11) "some string"
{% endhighlight %}

It is important to realize that ``stream_get_contents(STDIN)`` is blocking call.
If you want the application to run, regardless of the availability of data in the input stream,
you can use the following approach:

{% highlight php %}
#!/usr/bin/env php
<?php //non_blocking_stdin
$read = [STDIN];
$write = null;
$except = null;
if (stream_select($read, $write, $except, 0) === 1) {
   var_dump(trim(stream_get_contents(STDIN)));
} else {
   echo "Data is not available in STDIN\n";
}
{% endhighlight %}

Usage:

{% highlight sh %}
$ non_blocking_stdin
Data is not available in STDIN
$ non_blocking_stdin <<< "Hello"
string(5) "Hello"
{% endhighlight %}

## Composition of Shell programs

One of the beautiful opportunities of Shell is composition of programs.
It helps to follow the principle "one program – one task"
and build solutions of multiple problems with several tools at the same time.

### Sequential execution

Simplest approach of program's composition is sequential execution:

{% highlight sh %}
$ stdout; stdout
Content
Content
{% endhighlight %}

It is execution of programs one after one.

### Determining the success of the program

It is often necessary that the program in the chain depended on the success of the previous program.
The success of the execution of the program is determined by the return code: 0 - successful, otherwise - error.

Return code of PHP applications is argument of the function ``exit``.
In Shell, the return code of the previous command is determined by using ``$?``.

{% highlight php %}
<?php //ok.php
fwrite(STDOUT, "OK\n");
exit(0);
{% endhighlight %}

{% highlight php %}
<?php //fail.php
fwrite(STDERR, "FAIL\n");
exit(1);
{% endhighlight %}

Usage:

{% highlight sh %}
$ php ok.php
OK
$ echo $?
0
$ php fail.php
FAIL
$ echo $?
1
{% endhighlight %}

### Conditional execution

Program execution in case of success previous is possible through operator ``&&``:

{% highlight sh %}
$ php fail.php && php ok.php
FAIL
$ echo $?
1
{% endhighlight %}

Program execution in case of failure previous is possible through operator ``||``:

{% highlight sh %}
$ php ok.php || php fail.php
OK
$ echo $?
0
{% endhighlight %}

### Pipeline execution

The most powerful (IMO) ability of composition programs in Shell is pipeline execution.
The essence of the pipeline that the data of output stream of one program is sent to the input stream of another program.
It is possible through operator ``|``:

{% highlight sh %}
$ stdout | stdin | stdin | stdin
string(32) "string(19) "string(7) "Content"""
{% endhighlight %}

## Conclusion

I hope that this post gives to you initial idea how to work with PHP in Shell.
If some aspect of this post is not clear enough, feel free to ask about it in comments.